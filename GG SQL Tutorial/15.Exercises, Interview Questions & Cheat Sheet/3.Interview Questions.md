### Perguntas básicas da entrevista SQL

**"Perguntas básicas da entrevista SQL**" abrange conceitos fundamentais que são essenciais para qualquer pessoa que esteja se preparando para uma **entrevista** [SQL](https://www.geeksforgeeks.org/sql-tutorial/). Explore essas questões essenciais para construir uma forte compreensão e aumentar nossa confiança nos **fundamentos do SQL**.

### **1. O que é SQL?**

SQL (Structured Query Language) é uma linguagem de programação padrão usada para se comunicar com **bancos de dados relacionais**. Ele permite que os usuários criem, leiam, atualizem e excluam dados e fornece comandos para definir o [esquema do banco de dados](https://www.geeksforgeeks.org/database-schemas/) e gerenciar a segurança do banco de dados.

### **2. O que é um banco de dados?**

Um [banco de dados](https://www.geeksforgeeks.org/what-is-database/) é uma **coleção organizada de dados** armazenados eletronicamente, normalmente estruturados em tabelas com linhas e colunas. Ele é gerenciado por um **sistema de gerenciamento de banco de dados** (DBMS), que permite **armazenamento**, **recuperação** e **manipulação** eficientes de dados.

### **3. Quais são os principais tipos de comandos SQL?**

Os comandos SQL são amplamente classificados em:

- **DDL (Linguagem de Definição de Dados):** CRIAR, ALTERAR, DESCARTAR, TRUNCAR.
- **DML (Linguagem de Manipulação de Dados):** SELECIONAR, INSERIR, ATUALIZAR, EXCLUIR.
- **DCL (Linguagem de Controle de Dados):** GRANT, REVOKE.
- **TCL (Linguagem de Controle de Transações):** CONFIRMAR, REVERTER, SALVAR PONTO.

### **4. Qual é a diferença entre os tipos de dados CHAR e VARCHAR2?**

- **CHAR:** Armazenamento de comprimento fixo. Se o comprimento definido não for totalmente usado, ele será preenchido com espaços.
- **VARCHAR2:** Armazenamento de comprimento variável. Somente os dados reais são armazenados, economizando espaço quando o comprimento total não é necessário.

### **5. O que é uma chave primária?**

Uma [chave primária](https://www.geeksforgeeks.org/primary-key-constraint-in-sql/) é um identificador exclusivo para cada registro em uma tabela. Ele garante que duas linhas não tenham o mesmo valor na(s) coluna(s) de chave primária e não permite valores NULL.

### **6. O que é uma chave estrangeira?**

Uma [chave estrangeira](https://www.geeksforgeeks.org/foreign-key-constraint-in-sql/) é uma coluna (ou conjunto de colunas) em uma tabela que se refere à chave primária em outra tabela. Ele estabelece e impõe uma relação entre as duas tabelas, garantindo a integridade dos dados.

### **7. Qual é o propósito da restrição DEFAULT?**

A [restrição DEFAULT](https://www.geeksforgeeks.org/sql-default-constraint/) atribui um valor padrão a uma coluna quando nenhum valor é fornecido durante uma **operação INSERT**. Isso ajuda a manter dados consistentes e simplifica a entrada de dados.

### **8. O que é normalização em bancos de dados?**

[A normalização](https://www.geeksforgeeks.org/introduction-of-database-normalization/) é o processo de organizar dados em um banco de dados para **reduzir a redundância** e **melhorar a integridade dos dados**. Isso envolve dividir tabelas grandes em tabelas menores e relacionadas e definir relacionamentos entre elas para garantir a consistência e evitar anomalias.

### **9. O que é desnormalização e quando é usada?**

[A desnormalização](https://www.geeksforgeeks.org/denormalization-in-databases/) é o processo de combinar **tabelas normalizadas** em tabelas maiores por motivos de desempenho. Ele é usado quando **consultas e** junções complexas retardam a recuperação de dados e os benefícios de desempenho superam as **desvantagens da redundância**.

### **10. O que é uma consulta em SQL?**

Uma consulta é uma instrução SQL usada para recuperar, atualizar ou manipular dados em um **banco de dados**. O tipo mais comum de consulta é uma [instrução SELECT](https://www.geeksforgeeks.org/sql-select-query/), que busca dados de uma ou mais tabelas com base em condições especificadas.

### **11. Quais são os diferentes operadores disponíveis no SQL?**

- **Operadores aritméticos:** +, -, *, /, %
- **Operadores de comparação:** =, !=, <>, >, <, >><
- **Operadores lógicos:** AND, OR, NOT
- **Operadores de conjunto:** UNION, INTERSECT, EXCEPT
- **Operadores especiais:** BETWEEN, IN, LIKE, IS NULL

### **12. O que é uma visualização em SQL?**

Uma [exibição](https://www.geeksforgeeks.org/sql-views/) é uma **tabela virtual** criada por uma **consulta SELECT**. Ele não armazena dados em si, mas apresenta dados de uma ou mais tabelas de forma estruturada. As exibições simplificam consultas complexas, melhoram a legibilidade e aumentam a segurança restringindo o acesso a linhas ou colunas específicas.

### **13. Qual é o propósito da restrição UNIQUE?**

A [restrição UNIQUE](https://www.geeksforgeeks.org/sql-unique-constraint/) garante que todos os valores em uma coluna (ou combinação de colunas) sejam **distintos**. Isso evita valores duplicados e ajuda a manter a integridade dos dados.

### **14. Quais são os diferentes tipos de junções no SQL?**

- **INNER JOIN:** Retorna linhas que têm valores correspondentes em ambas as tabelas.
- **LEFT JOIN (LEFT OUTER JOIN):** Retorna todas as linhas da tabela esquerda e as linhas correspondentes da tabela direita.
- **RIGHT JOIN (RIGHT OUTER JOIN):** Retorna todas as linhas da tabela direita e as linhas correspondentes da tabela esquerda.
- **FULL JOIN (FULL OUTER JOIN):** Retorna todas as linhas quando há uma correspondência em qualquer uma das tabelas.
- **CROSS JOIN:** Produz o produto cartesiano de duas tabelas.

### **15. Qual é a diferença entre INNER JOIN e OUTER JOIN?**

- **INNER JOIN:** Retorna apenas linhas onde há uma correspondência em ambas as tabelas.
- **OUTER JOIN:** Retorna todas as linhas de uma tabela (LEFT, RIGHT ou FULL) e as linhas correspondentes da outra tabela. Se não houver correspondência, os valores NULL serão retornados para o lado não correspondente.

### **16. Qual é o objetivo da cláusula GROUP BY?**

A cláusula [GROUP BY](https://www.geeksforgeeks.org/sql-group-by/) é usada para organizar **dados idênticos** em **grupos**. Normalmente, é usado com funções agregadas (como COUNT, SUM, AVG) para realizar cálculos em cada grupo em vez de em todo o conjunto de dados.

### **17. O que são funções agregadas em SQL?**

As funções de agregação executam cálculos em um conjunto de valores e retornam um único valor. As funções agregadas comuns incluem:

- COUNT(): Retorna o número de linhas.
- SUM(): Retorna a soma total dos valores.
- AVG(): Retorna a média dos valores.
- MIN(): Retorna o menor valor.
- MAX(): Retorna o maior valor.

### **18. O que é uma subconsulta?**

Uma [subconsulta](https://www.geeksforgeeks.org/sql-subquery/) é uma consulta aninhada em outra consulta. Ele é frequentemente usado na **cláusula WHERE** para filtrar dados com base nos resultados de outra consulta, facilitando o tratamento de condições complexas.

### **19. Qual é a diferença entre as cláusulas WHERE e HAVING?**

- **ONDE:** Filtra as linhas antes que qualquer agrupamento ocorra.
- **HAVING:** filtra os dados agrupados após a aplicação da cláusula GROUP BY.
- Resumindo, WHERE se aplica a linhas individuais, enquanto HAVING se aplica a grupos.

### **20. O que são índices e por que são usados?**

[Os índices](https://www.geeksforgeeks.org/sql-indexes/) são **objetos de banco de dados** que melhoram o desempenho da consulta, permitindo a **recuperação mais rápida de linhas**. Eles funcionam como o índice de um livro, tornando mais rápido encontrar dados específicos sem digitalizar a tabela inteira. No entanto, os índices exigem **armazenamento adicional** e podem retardar um pouco as operações de **modificação de dados**.

### **21. Qual é a diferença entre os comandos DELETE e TRUNCATE?**

- **DELETE:** Remove linhas uma de cada vez e registra cada exclusão no log de transações, permitindo a reversão. Pode ter uma cláusula WHERE.
- **TRUNCATE:** remove todas as linhas de uma só vez sem registrar exclusões de linhas individuais. Ele não pode ter uma cláusula WHERE e é mais rápido que DELETE para grandes conjuntos de dados.

### **22. Qual é o objetivo da cláusula SQL ORDER BY?**

A cláusula [ORDER BY](https://www.geeksforgeeks.org/sql-order-by/) classifica o conjunto de resultados de uma consulta em ordem **crescente** (padrão) ou **decrescente**, com base em uma ou mais colunas. Isso ajuda a apresentar os dados em uma sequência mais significativa ou legível.

### **23. Quais são as diferenças entre bancos de dados SQL e NoSQL?**

- **Bancos de dados SQL:**
    - Use tabelas estruturadas com linhas e colunas.
    - Confie em um esquema fixo.
    - Oferece propriedades **ACID.**
- **Bancos de dados NoSQL:**
    - Use estruturas flexíveis e sem esquema (por exemplo, pares de valores-chave, armazenamentos de documentos).
    - São projetados para dimensionamento horizontal.
    - Muitas vezes, concentre-se no desempenho e na escalabilidade em vez de consistência estrita.

### **24. O que é uma tabela em SQL?**

Uma tabela é uma **coleção estruturada** de dados relacionados organizados em linhas e colunas. As colunas definem o tipo de dados armazenados, enquanto as linhas contêm registros individuais.

### **25. Quais são os tipos de restrições no SQL?**

As restrições comuns incluem:

- **NOT NULL:** garante que uma coluna não possa ter valores NULL.
- **UNIQUE:** garante que todos os valores em uma coluna sejam distintos.
- **PRIMARY KEY:** Identifica exclusivamente cada linha em uma tabela.
- **FOREIGN KEY:** Garante a integridade referencial vinculando-se a uma chave primária em outra tabela.
- **CHECK:** Garante que todos os valores em uma coluna atendam a uma condição específica.
- **DEFAULT:** Define um valor padrão para uma coluna quando nenhum valor é especificado.

### **26. O que é um cursor em SQL?**

Um [cursor](https://www.geeksforgeeks.org/what-is-cursor-in-sql/) é um objeto de banco de dados usado para **recuperar**, **manipular** e percorrer linhas em um conjunto de resultados, uma linha por vez. Os cursores são úteis ao executar operações que devem ser processadas sequencialmente, em vez de de maneira baseada em conjunto.

### **27. O que é um gatilho em SQL?**

Um [gatilho](https://www.geeksforgeeks.org/sql-trigger-student-database/) é um conjunto de instruções SQL que são executadas automaticamente em resposta a determinados eventos em uma tabela, como **INSERT**, **UPDATE** ou **DELETE.** Os gatilhos ajudam a manter a **consistência dos dados**, impor regras de negócios e implementar restrições de integridade complexas.

### **28. Qual é o objetivo da instrução SQL SELECT?**

A instrução [SELECT](https://www.geeksforgeeks.org/sql-select-query/) recupera dados de uma ou mais tabelas. É o comando mais comumente usado em SQL, permitindo que os usuários filtrem, classifiquem e exibam dados com base em critérios específicos.

### **29. O que são valores NULL em SQL?**

**NULL** representa um valor ausente ou desconhecido. É diferente de zero ou de uma string vazia. Os valores NULL indicam que os dados não estão disponíveis ou não são aplicáveis.

### **30. O que é um procedimento armazenado?**

Um [procedimento armazenado](https://www.geeksforgeeks.org/what-is-stored-procedures-in-sql/) é um conjunto pré-compilado de instruções SQL armazenadas no **banco de dados**. Ele pode usar parâmetros de entrada, executar lógica e consultas e retornar valores de saída ou conjuntos de resultados. Os procedimentos armazenados melhoram o **desempenho** e a **capacidade de manutenção** centralizando a lógica de negócios.

## Perguntas da entrevista intermediária do SQL

Esta seção aborda **tópicos SQL** moderadamente complexos, como **consultas avançadas**, **junções de várias tabelas**, **subconsultas** e **técnicas básicas de otimização**. Essas perguntas ajudam a aprimorar as habilidades de desenvolvedores e **administradores** **de banco de dados**, preparando-nos para desafios SQL mais **técnicos** no campo.

### **31. Qual é a diferença entre os comandos DDL e DML?**

**1. DDL (Linguagem de Definição de Dados):**

Esses comandos são usados para **definir** e **modificar a estrutura de objetos de banco de dados**, como **tabelas**, índices e **exibições**. Por exemplo, o **comando** `**CREATE**` cria uma nova tabela, o **comando** `**ALTER**` modifica uma tabela existente e o **comando** `**DROP**` remove uma tabela inteiramente. [Os comandos DDL](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/) se concentram principalmente no esquema ou na estrutura do banco de dados.

**Exemplo:**

CREATE TABLE Employees (
    ID INT PRIMARY KEY,
    Name VARCHAR(50)
);

**2. DML (Linguagem de Manipulação de Dados):**

Esses comandos lidam com os **dados reais armazenados** em objetos de banco de dados. Por exemplo, o **comando** `**INSERIR**` adiciona linhas de dados a uma tabela, o comando `**ATUALIZAR**` modifica os dados existentes e o comando `**EXCLUIR**` remove linhas de uma tabela. Resumindo, os comandos [DML](https://www.geeksforgeeks.org/sql-ddl-dql-dml-dcl-tcl-commands/) permitem que você consulte e manipule os dados em si, em vez da estrutura.

**Exemplo:**

INSERT INTO Employees (ID, Name) VALUES (1, 'Alice');

### **32. Qual é o propósito do comando ALTER em SQL?**

O comando `[ALTER](https://www.geeksforgeeks.org/sql-alter-add-drop-modify/)` é usado para **modificar a estrutura** de um objeto de banco de dados existente. Esse comando é essencial para adaptar nosso **esquema de banco de dados** à medida que os requisitos evoluem.

- Adicione ou solte uma coluna em uma tabela.
- Altere o tipo de dados de uma coluna.
- Adicione ou remova restrições.
- Renomeie colunas ou tabelas.
- Ajuste as configurações de indexação ou armazenamento.

### **33. O que é uma chave primária composta?**

Uma**chave primária composta** é uma chave primária composta por duas ou mais colunas. Juntas, essas colunas devem formar uma combinação exclusiva para cada linha da tabela. Ele é usado quando uma única coluna não é suficiente para identificar exclusivamente um registro.

**Exemplo:**

Considere uma tabela Pedidos em que e juntos identifiquem exclusivamente cada registro, pois vários pedidos podem incluir o mesmo produto, mas não dentro do mesmo pedido.`OrderIDProductID`

CREATE TABLE OrderDetails (
    OrderID INT,
    ProductID INT,
    Quantity INT,
    PRIMARY KEY (OrderID, ProductID)
);

### **34. Como a integridade dos dados é mantida em bancos de dados SQL?**

A integridade dos dados refere-se à **precisão**, **consistência** e **confiabilidade** dos dados armazenados no banco de dados. Os bancos de dados SQL mantêm a integridade dos dados por meio de vários mecanismos:

- **Restrições:** Garantir que certas condições sejam sempre atendidas. Por exemplo, garante que uma coluna não possa ter valores ausentes, garante uma relação válida entre tabelas e garante que não haja valores duplicados.`NOT NULLFOREIGN KEYUNIQUE`
- **Transações:** Garantir que uma série de operações seja bem-sucedida ou todas falhem, preservando a consistência dos dados.
- **Gatilhos:** impor automaticamente regras ou validações antes ou depois das alterações nos dados.
- **Normalização:** organizar dados em várias tabelas relacionadas para minimizar a redundância e evitar anomalias.
- Essas medidas garantem coletivamente que os dados permaneçam confiáveis e significativos ao longo do tempo.

### **35. Quais são as vantagens de usar procedimentos armazenados?**

- **Desempenho aprimorado:** os procedimentos armazenados são pré-compilados e armazenados em cache no banco de dados, tornando sua execução mais rápida do que o envio de várias consultas individuais.
- **Tráfego de rede reduzido:** ao executar lógica complexa no servidor, são necessárias menos viagens de ida e volta entre o aplicativo e o banco de dados.
- **Segurança aprimorada:** os procedimentos armazenados podem restringir o acesso direto às tabelas subjacentes, permitindo que os usuários executem apenas operações autorizadas.
- **Reutilização e manutenção:** Depois que um procedimento é escrito, ele pode ser reutilizado em vários aplicativos. Se a lógica de negócios for alterada, você só precisará atualizar o procedimento armazenado, não todos os aplicativos que o utilizam.

### **36. O que é uma operação UNION e como ela é usada?**

O [operador](https://www.geeksforgeeks.org/sql-union-operator/) `[UNION](https://www.geeksforgeeks.org/sql-union-operator/)` combina os conjuntos de resultados de duas ou mais [consultas](https://www.geeksforgeeks.org/sql-select-query/) `[SELECT](https://www.geeksforgeeks.org/sql-select-query/)` em um único conjunto de resultados, removendo **linhas duplicadas**. Os conjuntos de resultados devem ter o mesmo número de colunas e tipos de dados compatíveis para as colunas correspondentes.

**Exemplo:**

SELECT Name FROM Customers  
UNION  
SELECT Name FROM Employees;

### **37. Qual é a diferença entre UNION e UNION ALL?**

- **UNION:** combina conjuntos de resultados de duas consultas e remove **linhas duplicadas**, garantindo que apenas registros exclusivos sejam retornados.
- **UNION ALL:** Combina os conjuntos de resultados sem remover duplicatas, o que significa que todos os registros de ambas as consultas são incluídos.
- Em termos de desempenho, `[UNION ALL](https://www.geeksforgeeks.org/sql-union-all/)` é mais rápido que UNION porque não executa a operação adicional de eliminação de duplicatas.

**Exemplo:**

SELECT Name FROM Customers  
UNION ALL  
SELECT Name FROM Employees;

### **38. Como funciona a instrução CASE em SQL?**

A [instrução](https://www.geeksforgeeks.org/sql-case-statement/) `[CASE](https://www.geeksforgeeks.org/sql-case-statement/)` é a maneira do SQL de implementar **lógica condicional** em consultas. Ele avalia as condições e retorna um valor com base na primeira condição que é avaliada como verdadeira. Se nenhuma condição for atendida, ele poderá retornar um valor padrão usando a **cláusula** `**ELSE**`.

**Exemplo:**

SELECT ID,  
       CASE  
           WHEN Salary > 100000 THEN 'High'  
           WHEN Salary BETWEEN 50000 AND 100000 THEN 'Medium'  
           ELSE 'Low'  
       END AS SalaryLevel  
FROM Employees;

### **39. O que são funções escalares em SQL?**

[As funções escalares](https://www.geeksforgeeks.org/sql-functions-aggregate-scalar-functions/) operam em valores individuais e, como resultado, retornam um único valor. Eles são frequentemente usados para formatar ou converter dados. Exemplos comuns incluem:

- **LEN():** Retorna o comprimento de uma string.
- **ROUND():** Arredonda um valor numérico.
- **CONVERT():** Converte um valor de um tipo de dados para outro.

**Exemplo:**

SELECT LEN('Example') AS StringLength;

### **40. Qual é a finalidade da função COINESCE?**

A **função** `**COALESCE**` retorna o primeiro valor não NULL de uma lista de expressões. É comumente usado para fornecer valores padrão ou lidar com dados ausentes normalmente.

**Exemplo:**

SELECT COALESCE(NULL, NULL, 'Default Value') AS Result;

### **41. Quais são as diferenças entre as funções COUNT() e SUM() do SQL?**

**1. COUNT():** Conta o número de linhas ou valores não NULL em uma coluna.

**Exemplo:**

SELECT COUNT(*) FROM Orders;

**2. SUM():** Soma todos os valores numéricos em uma coluna.

**Exemplo:**

SELECT SUM(TotalAmount) FROM Orders;

### **42. Qual é a diferença entre as funções NVL e NVL2?**

- **NVL():** Substitui um valor NULL por um valor de substituição especificado. **Exemplo**: substituirá por . `NVL(Salary, 0)NULL0`
- **NVL2():** Avalia dois argumentos:
    - Se o primeiro argumento **for NOT NULL,** retornará o segundo argumento.
    - Se o primeiro argumento for **NULL,** retornará o terceiro argumento.

**Exemplo:**

SELECT NVL(Salary, 0) AS AdjustedSalary FROM Employees;  -- Replaces NULL with 0

SELECT NVL2(Salary, Salary, 0) AS AdjustedSalary FROM Employees;  -- If Salary is NULL, returns 0; otherwise, returns Salary.

### **43. Como a função RANK() difere de DENSE_RANK()?**

- **RANK():** Atribui uma classificação a cada linha, com lacunas se houver empates.
- **DENSE_RANK():** Atribui classificações consecutivas sem lacunas.

**Exemplo:**

SELECT Name, Salary, RANK() OVER (ORDER BY Salary DESC) AS Rank  
FROM Employees;

Se dois funcionários tiverem o mesmo salário, eles obterão a mesma classificação, mas pularão um número para a próxima classificação, enquanto não o farão.`RANK()DENSE_RANK()`

### **44. Qual é a diferença entre ROW_NUMBER() e RANK()?**

- **ROW_NUMBER():** Atribui um número exclusivo a cada linha, independentemente dos empates.
- **RANK():** Atribui o mesmo número a linhas empatadas e deixa lacunas para as classificações subsequentes.

**Exemplo:**

SELECT Name, ROW_NUMBER() OVER (ORDER BY Salary DESC) AS RowNum  
FROM Employees;

### **45. O que são expressões de tabela comuns (CTEs) em SQL?**

Uma [CTE](https://www.geeksforgeeks.org/cte-in-sql/) é um conjunto de resultados temporário definido em uma consulta. Ele melhora a legibilidade da consulta e pode ser referenciado várias vezes.

**Exemplo:**

WITH TopSalaries AS (  
    SELECT Name, Salary  
    FROM Employees  
    WHERE Salary > 50000  
)  
SELECT * FROM TopSalaries WHERE Name LIKE 'A%';

### **46. O que são funções de janela e como são utilizadas?**

**As funções de janela** permitem que você execute cálculos em um conjunto de linhas de tabela relacionadas à linha atual em um conjunto de resultados, sem recolher o conjunto de resultados em uma única linha. Essas funções podem ser usadas para calcular totais acumulados, médias móveis, linhas de classificação, etc.

#### **Exemplo:** Calculando um Total Acumulado

SELECT Name, Salary, 
    SUM(Salary) OVER (ORDER BY Salary) AS RunningTotal  
FROM Employees;

### **47. Qual é a diferença entre um índice e uma chave em SQL?**

**1. Índice**

- Um [índice](https://www.geeksforgeeks.org/sql-indexes/) é um objeto de banco de dados criado para **acelerar a recuperação de dados**. Ele armazena uma referência classificada aos dados da tabela, o que ajuda o mecanismo de banco de dados a encontrar linhas mais rapidamente do que a verificação de toda a tabela.
- **Exemplo:** Um índice não exclusivo em uma coluna como permite pesquisas rápidas de linhas em que o sobrenome corresponde a um valor específico.`LastName`

2. **Chave**

- Uma chave é um conceito lógico que impõe regras para exclusividade ou relacionamentos nos dados.
- Por exemplo, uma **PRIMARY KEY** identifica exclusivamente cada linha em uma tabela e garante que não existam valores duplicados ou NULL na(s) coluna(s) de chave.
- Uma **chave estrangeira mantém** a integridade referencial vinculando linhas em uma tabela a linhas em outra.

### **48. Como a indexação melhora o desempenho da consulta?**

A indexação permite que o [banco de dados](https://www.geeksforgeeks.org/what-is-database/) localize e acesse as linhas correspondentes a uma **condição de consulta** muito mais rapidamente do que a verificação de toda a tabela. Em vez de ler cada linha sequencialmente, o banco de dados usa o índice para **ir diretamente** para as páginas de dados relevantes. Isso reduz o número de **operações de E/S** de disco e acelera a execução da consulta, especialmente para tabelas grandes.

**Exemplo:**

CREATE INDEX idx_lastname ON Employees(LastName);
SELECT * FROM Employees WHERE LastName = 'Smith';

O índice ativado permite que o banco de dados encontre rapidamente todas as linhas correspondentes a 'Smith' sem verificar todos os registros.`LastName`

### **49. Quais são as vantagens e desvantagens do uso de índices em bancos de dados SQL?**

**Vantagens**

- Desempenho de consulta mais rápido, especialmente para consultas SELECT com cláusulas [WHERE](https://www.geeksforgeeks.org/sql-where-clause/), condições JOIN ou cláusulas ORDER BY.
- Maior eficiência de classificação e filtragem.

**Desvantagens:**

- Maior espaço de armazenamento para as estruturas de índice.
- Sobrecarga adicional para operações de gravação (INSERT, UPDATE, DELETE), pois os índices devem ser atualizados sempre que os dados subjacentes forem alterados.
- **Carregamento de dados em massa**ou inserções em lote potencialmente mais lentos devido à necessidade de manter a integridade do índice.
- Em resumo, os índices tornam as operações de leitura mais rápidas, mas podem retardar as operações de gravação e aumentar os requisitos de armazenamento.

### **50. Qual é a diferença entre índices clusterizados e não clusterizados?**

**1. Índice agrupado:**

- Organiza os dados físicos na própria tabela na ordem da(s) coluna(s) indexada(s).
- Uma tabela pode ter apenas um [índice clusterizado](https://www.geeksforgeeks.org/difference-between-clustered-and-non-clustered-index/).
- Melhora as consultas de intervalo e as consultas que classificam dados.
- Exemplo: Se for o índice clusterizado, as linhas na tabela serão armazenadas fisicamente classificadas por .`EmployeeIDEmployeeID`

**2. Índice não clusterizado:**

- Mantém uma estrutura separada que contém uma referência (ou ponteiro) para os dados físicos na tabela.
- Uma tabela pode ter vários índices não clusterizados.
- Útil para condições de consulta específicas que não estão relacionadas à ordenação primária dos dados.
- Exemplo: Um índice não clusterizado permite pesquisas rápidas por sobrenome, mesmo que a tabela seja classificada por outra coluna.`LastName`

### **51. O que são tabelas temporárias e como são usadas?**

[Tabelas temporárias](https://www.geeksforgeeks.org/what-is-temporary-table-in-sql/) são tabelas que existem apenas durante uma **sessão** ou **transação**. Eles são úteis para armazenar resultados intermediários, simplificar consultas complexas ou executar operações em subconjuntos de dados sem modificar as tabelas principais.

**1. Tabelas Temporárias Locais:**

- Prefixado com (por exemplo, ).`##TempTable`
- Visível apenas para a sessão que os criou.
- Descartado automaticamente quando a sessão termina.

**2. Tabelas Temporárias Globais:**

- Prefixado com (por exemplo, ).`####GlobalTempTable`
- Visível para todas as sessões.
- Descartado quando todas as sessões que fazem referência a eles são fechadas.

**Exemplo:**

CREATE TABLE #TempResults (ID INT, Value VARCHAR(50));
INSERT INTO #TempResults VALUES (1, 'Test');
SELECT * FROM #TempResults;

### **52. O que é uma visão materializada, e como ela difere de uma visão padrão?**

- **Visualização padrão:**
    - Uma tabela virtual definida por uma consulta.
    - Não armazena dados; A consulta subjacente é executada sempre que a exibição é referenciada.
    - Uma visualização padrão mostra dados em tempo real.
- **Visualização Materializada:**
    - Uma tabela física que armazena o resultado da consulta.
    - Os dados são pré-computados e armazenados, tornando as leituras mais rápidas.
    - Requer atualizações periódicas para manter os dados atualizados.
    - A exibição materializada é usada para armazenar dados de vendas agregados, atualizados todas as noites, para relatórios rápidos.

### **53. O que é uma sequência em SQL?**

Uma [sequência](https://www.geeksforgeeks.org/sql-sequences/) é um objeto de banco de dados que gera uma série de **valores numéricos exclusivos**. Ele geralmente é usado para produzir identificadores exclusivos para chaves primárias ou outras colunas que exigem valores sequenciais.

**Exemplo:**

CREATE SEQUENCE seq_emp_id START WITH 1 INCREMENT BY 1;
SELECT NEXT VALUE FOR seq_emp_id; -- Returns 1
SELECT NEXT VALUE FOR seq_emp_id; -- Returns 2

### **54. Quais são as vantagens de usar sequências em vez de colunas de identidade?**

**1. Maior flexibilidade:**

- Pode especificar valores iniciais, incrementos e valores máximos.
- Pode ser facilmente reutilizado para várias tabelas.

**2. Ajuste dinâmico:** Pode alterar a sequência sem modificar a estrutura da tabela.

**3. Consistência entre tabelas:** use uma única sequência para várias tabelas relacionadas para garantir identificadores exclusivos entre elas.

Em resumo, as sequências oferecem mais controle e reutilização do que as colunas de identidade.

### **55. Como as restrições melhoram a integridade do banco de dados?**

As restrições impõem regras que os dados devem seguir, impedindo que dados inválidos ou inconsistentes sejam inseridos:

- **NOT NULL:** Garante que uma coluna não possa conter valores NULL.
- **UNIQUE:** garante que todos os valores em uma coluna sejam distintos.
- **PRIMARY KEY:** Combina NOT NULL e UNIQUE, garantindo que cada linha seja identificável de forma exclusiva.
- **FOREIGN KEY:** Garante a integridade referencial exigindo que os valores em uma tabela correspondam aos valores de chave primária em outra.
- **CHECK:** valida se os valores atendem a critérios específicos (por exemplo, ).
- Ao impor automaticamente essas regras, as restrições mantêm a confiabilidade e a consistência dos dados.`CHECK (Salary > 0)`

### **56. Qual é a diferença entre uma tabela temporária local e uma global?**

- **Tabela temporária local:**
    - Prefixado com (por exemplo, ).`##TempTable`
    - Existe apenas na sessão que o criou.
    - Descartado automaticamente quando a sessão termina.
- **Tabela Temporária Global:**
    - Prefixado com (por exemplo, ).`####GlobalTempTable`
    - Visível para todas as sessões.
    - Descartado somente quando todas as sessões que fazem referência a ele são fechadas.

**Exemplo:**

CREATE TABLE #LocalTemp (ID INT);
CREATE TABLE ##GlobalTemp (ID INT);

### **57. Qual é o objetivo da instrução SQL MERGE?**

A **instrução** `**MERGE**` combina várias operações INSERT, UPDATE e DELETE em uma. Ele é usado para sincronizar duas tabelas:

- Inserir linhas que não existem na tabela de destino.
- Atualizando linhas que já existem.
- Excluindo linhas da tabela de destino com base em condições

**Exemplo:**

MERGE INTO TargetTable T  
USING SourceTable S  
ON T.ID = S.ID  
WHEN MATCHED THEN  
    UPDATE SET T.Value = S.Value  
WHEN NOT MATCHED THEN  
    INSERT (ID, Value) VALUES (S.ID, S.Value);

### **58. Como você pode lidar com duplicatas em uma consulta sem usar DISTINCT?**

**1. GROUP BY:** Agregue linhas para eliminar duplicatas

SELECT Column1, MAX(Column2)  
FROM TableName  
GROUP BY Column1;

2. **ROW_NUMBER():** Atribua um número exclusivo a cada linha e filtre por isso

WITH CTE AS (  
    SELECT Column1, Column2, ROW_NUMBER() OVER (PARTITION BY Column1 ORDER BY Column2) AS RowNum  
    FROM TableName  
)  
SELECT * FROM CTE WHERE RowNum = 1;

### **59. O que é uma subconsulta correlacionada?**

Uma [subconsulta correlacionada](https://www.geeksforgeeks.org/sql-correlated-subqueries/) é uma subconsulta que faz referência a colunas da consulta externa. Ele é executado novamente para cada linha processada pela consulta externa. Isso o torna mais dinâmico, mas potencialmente menos eficiente.

**Exemplo:**

SELECT Name,  
       (SELECT COUNT(*)  
        FROM Orders  
        WHERE Orders.CustomerID = Customers.CustomerID) AS OrderCount  
FROM Customers;

### **60. O que são tabelas particionadas, e quando devemos usá-las?**

**As tabelas particionadas** dividem os dados em segmentos **menores** e mais **gerenciáveis** com base no valor de uma coluna (por exemplo, data ou região). Cada partição é armazenada separadamente, tornando as consultas direcionadas a uma partição específica mais eficientes. É usado quando

- Tabelas grandes com milhões ou bilhões de linhas.
- Cenários em que as consultas filtram frequentemente em colunas particionadas (por exemplo, ano, região).
- Para melhorar as operações de manutenção, como arquivar partições mais antigas sem afetar o restante da tabela.

## Perguntas da entrevista avançada do SQL

Esta seção aborda **tópicos complexos de SQL**, incluindo **ajuste de desempenho**, **estratégias complexas de indexação**, **níveis de isolamento de transação** e **técnicas avançadas de otimização de consulta**. Ao abordar essas questões desafiadoras, obteremos uma compreensão mais profunda do SQL, preparando-nos para **funções de nível sênior** e **entrevistas técnicas**.

### **61. Quais são as propriedades ACID de uma transação?**

[ACID](https://www.geeksforgeeks.org/acid-properties-in-dbms/) é um acrônimo que significa Atomicidade, Consistência, Isolamento e Durabilidade - quatro propriedades principais que garantem que as transações do banco de dados sejam processadas de forma confiável.

1. **Atomicidade:**

- Uma transação é tratada como uma única unidade de trabalho, o que significa que todas as operações devem ser bem-sucedidas ou falhar como um todo.
- Se qualquer parte da transação falhar, toda a transação será revertida.

2. **Consistência:**

- Uma transação deve levar o banco de dados de um estado válido para outro, mantendo todas as regras e restrições definidas.
- Isso garante que a integridade dos dados seja preservada durante todo o processo de transação.

3. **Isolação:**

- As transações não devem interferir umas nas outras.
- Mesmo que várias transações ocorram simultaneamente, cada uma deve operar como se fosse a única no sistema até que seja concluída.

4. **Durabilidade:**

- Depois que uma transação é confirmada, suas alterações devem persistir, mesmo no caso de uma falha do sistema.
- Isso garante que os dados permaneçam estáveis após a conclusão bem-sucedida da transação.

### **62. Quais são as diferenças entre os níveis de isolamento no SQL?**

**Os níveis de isolamento** definem até que ponto as operações em uma [transação](https://www.geeksforgeeks.org/sql-transactions/) são isoladas daquelas em outras transações. Eles são essenciais para **gerenciar a simultaneidade** e garantir a integridade dos dados. Os níveis de isolamento comuns incluem:

**1. Leia não comprometido:**

- Permite ler alterações não confirmadas de outras transações.
- Pode resultar em leituras sujas, em que uma transação lê dados que podem ser revertidos posteriormente.

**2. Leia Confirmado:**

- Garante que uma transação só possa ler dados confirmados.
- Evita leituras sujas, mas não protege contra leituras não repetíveis ou leituras fantasmas.

**3. Leitura repetível:**

- Garante que, se uma transação ler uma linha, essa linha não poderá ser alterada até que a transação seja concluída.
- Evita leituras sujas e leituras não repetíveis, mas não leituras fantasmas.

**4. Serializável:**

- O mais alto nível de isolamento.
- Garante o isolamento total serializando transações com eficiência, o que significa que nenhuma outra transação pode ler ou modificar dados que outra transação está usando.
- Evita leituras sujas, leituras não repetíveis e leituras fantasmas, mas pode introduzir sobrecarga de desempenho devido ao bloqueio e à simultaneidade reduzida.

### **63. Qual é a finalidade da dica WITH (NOLOCK) no SQL Server?**

- A dica **WITH (NOLOCK)** permite que uma consulta leia dados sem adquirir bloqueios compartilhados, lendo efetivamente dados não confirmados.
- Ele pode melhorar o desempenho **reduzindo a contenção de bloqueios**, especialmente em tabelas grandes que são atualizadas com frequência.
- Os resultados podem ser inconsistentes ou não confiáveis, pois os dados lidos podem ser alterados ou revertidos.

**Exemplo:**

SELECT *  
FROM Orders WITH (NOLOCK);

Essa consulta busca dados da tabela sem esperar que outras transações liberem seus bloqueios.`Orders`

### **64. Como você lida com deadlocks em bancos de dados SQL?**

[Os deadlocks](https://www.geeksforgeeks.org/deadlock-in-dbms/) ocorrem quando duas ou mais transações contêm recursos de que as outras transações precisam, resultando em um ciclo de dependência que impede o progresso. As estratégias para lidar com deadlocks incluem:

1. **Detecção de deadlock e nova tentativa:**

- Muitos sistemas de banco de dados têm mecanismos para detectar deadlocks e encerrar uma das transações para interromper o ciclo.
- A transação encerrada pode ser repetida após a conclusão das outras transações.

2. **Reduzindo a contenção de bloqueio:**

- Use índices e consultas otimizadas para minimizar a duração e o escopo dos bloqueios.
- Divida as transações em etapas menores para reduzir a probabilidade de conflitos.

3. **Usando níveis de isolamento adequados:**

- Em alguns casos, níveis de isolamento mais baixos podem ajudar a reduzir o bloqueio.
- Por outro lado, níveis de isolamento mais altos (como Serializable) podem garantir uma ordem previsível de operações, reduzindo o risco de deadlock.

4. **Ordenação consistente de acesso a recursos:**

- Certifique-se de que as transações adquiram recursos na mesma ordem para evitar dependências cíclicas.

### **65. O que é um instantâneo de banco de dados e como ele é usado?**

Um [instantâneo de banco de dados](https://www.geeksforgeeks.org/sql-snapshots/) é uma exibição estática somente leitura de um banco de dados em um ponto específico no tempo.

- **Relatórios:** permitindo que os usuários consultem um conjunto de dados consistente sem afetar as operações ao vivo.
- **Backup e recuperação:** os snapshots podem servir como uma fonte de recuperação point-in-time se as alterações precisarem ser revertidas.
- **Teste:** Fornecer um conjunto de dados estável para fins de teste sem o risco de modificar os dados originais.

**Exemplo:**

CREATE DATABASE MySnapshot ON  
(  
    NAME = MyDatabase_Data,  
    FILENAME = 'C:\Snapshots\MyDatabase_Snapshot.ss'  
)  
AS SNAPSHOT OF MyDatabase;

### **66. Quais são as diferenças entre os sistemas OLTP e OLAP?**

1. **OLTP (Processamento de Transações Online)**

- Lida com grandes volumes de transações simples (por exemplo, entrada de pedidos, atualizações de estoque).
- Otimizado para leituras e gravações rápidas e frequentes.
- Esquema normalizado para garantir a integridade e consistência dos dados.
- Exemplos: sites de comércio eletrônico, sistemas bancários.

2. **OLAP (Processamento Analítico Online)**

- Lida com consultas e análises complexas em grandes conjuntos de dados.
- Otimizado para cargas de trabalho com uso intenso de leitura e agregação de dados.
- Esquema desnormalizado (por exemplo, esquemas em estrela ou floco de neve) para oferecer suporte a consultas mais rápidas.
- Exemplos: relatórios de business intelligence, data warehouse.

### **67. O que é um bloqueio ativo e como ele difere de um impasse?**

**1. Bloqueio ao vivo**

- Ocorre quando duas ou mais transações continuam respondendo às alterações umas das outras, mas nenhum progresso é feito.
- Ao contrário de um deadlock, as transações não são bloqueadas; eles estão em execução ativamente, mas não podem ser concluídos.

2. **Impasse**

- Um **deadlock** ocorre quando duas ou mais transações estão aguardando os recursos uma da outra indefinidamente, bloqueando todo o progresso.
- Nenhum progresso pode ser feito a menos que uma das transações seja encerrada

### **68. Qual é a finalidade do operador SQL EXCEPT?**

O [operador](https://www.geeksforgeeks.org/sql-except-clause/) `[EXCEPT](https://www.geeksforgeeks.org/sql-except-clause/)` é usado para retornar linhas do conjunto de resultados de uma consulta que não estão presentes no conjunto de resultados de outra consulta. Ele executa efetivamente uma diferença de conjunto, mostrando apenas os dados **exclusivos** da primeira consulta.

**Exemplo:**

SELECT ProductID FROM ProductsSold
EXCEPT
SELECT ProductID FROM ProductsReturned;

**Caso de uso:**

- Para encontrar discrepâncias entre conjuntos de dados.
- Para verificar se determinados dados existem em um conjunto de dados, mas não em outro.

**Considerações de desempenho:**

- `**EXCEPT**` **funciona** melhor quando os conjuntos de dados envolvidos têm indexação apropriada e quando os conjuntos de resultados são relativamente pequenos.
- Grandes conjuntos de dados sem índices podem causar um desempenho mais lento porque o banco de dados precisa comparar cada linha.

### **69. Como você implementa o SQL dinâmico e quais são suas vantagens e riscos?**

[SQL dinâmico](https://www.geeksforgeeks.org/dynamic-sql/) é um código SQL que é construído e executado em **tempo de execução**, em vez de ser totalmente definido e estático. No SQL Server: Use `**sp_executesql**` ou Em outros bancos de dados: Concatene cadeias de caracteres de consulta e execute-as usando o respectivo comando para a plataforma de banco de dados.`EXEC.`

**Sintaxe:**

> _DECLARE @sql NVARCHAR(MAX)_

> _SET @sql = 'SELECT * FROM ' + @TableName_

> _EXEC sp_executesql @sql;_

**Vantagens:**

- **Flexibilidade:** o SQL dinâmico pode se adaptar a diferentes condições, tabelas ou colunas que são conhecidas apenas no tempo de execução.
- **Simplifica a lógica complexa:** em vez de escrever várias consultas, uma única consulta construída dinamicamente pode lidar com vários cenários.

**Riscos:**

- **Vulnerabilidades de injeção de SQL:** se a entrada do usuário não for higienizada, os invasores podem injetar código SQL malicioso.
- **Sobrecarga de desempenho:** como o SQL dinâmico é construído em tempo de execução, ele pode não se beneficiar dos planos de execução armazenados em cache, levando a um desempenho mais lento.
- **Complexidade na depuração:** as consultas dinâmicas podem ser mais difíceis de ler e solucionar problemas.

### **70. Qual é a diferença entre particionamento horizontal e vertical?**

**O particionamento** é uma técnica de banco de dados usada para dividir os dados em partes menores e mais gerenciáveis.

- **Particionamento horizontal:**
    - Divide as linhas de uma tabela em várias partições com base nos valores de uma coluna específica.
    - Exemplo: Dividir uma tabela de cliente em partições separadas por região geográfica ou por ano.
    - **Caso de uso:** ao lidar com grandes conjuntos de dados, o particionamento horizontal pode melhorar o desempenho limitando o número de linhas verificadas para uma consulta.
- **Particionamento vertical:**
    - Divide as colunas de uma tabela em várias partições.
    - Exemplo: Armazenar colunas acessadas com pouca frequência (por exemplo, texto grande ou campos binários) em uma tabela ou partição separada.
    - **Caso de uso:** ajuda a otimizar o desempenho do armazenamento e da consulta, separando as colunas comumente usadas dos dados acessados com menos frequência.
- **Diferença chave:**
    - O particionamento horizontal é baseado em linhas, concentrando-se na distribuição das linhas do conjunto de dados entre partições.
    - O particionamento vertical é baseado em colunas, com o objetivo de separar colunas menos usadas em diferentes partições ou tabelas.

### **71. Quais são as considerações para indexar tabelas muito grandes?**

**1. Estratégia de indexação:**

- Concentre-se nas colunas consultadas com mais frequência ou naquelas envolvidas nas condições [JOIN](https://www.geeksforgeeks.org/sql-join-set-1-inner-left-right-and-full-joins/) e WHERE.
- Evite indexar todas as colunas, pois isso aumenta os custos de armazenamento e manutenção.

**2. Tipos de índice:**

- Use índices clusterizados para pesquisas de chave primária e consultas de intervalo.
- Use índices não clusterizados para filtrar, ordenar e cobrir consultas específicas.

**3. Índices particionados:**

- Se a tabela for particionada, considere a criação **de índices locais** para cada partição. Isso melhora a capacidade de gerenciamento e pode acelerar as consultas direcionadas a partições específicas.

**4. Despesas gerais de manutenção:**

- A recriação e a atualização de índices podem consumir muitos recursos. Planeje a manutenção regular do índice fora do horário de pico.
- Monitore a fragmentação do índice e recompile os índices conforme necessário para manter o desempenho.

**5. Monitoramento e ajuste:**

- Avalie continuamente o desempenho da consulta usando planos de execução e estatísticas.
- Remova índices não utilizados ou raramente acessados para reduzir os custos de manutenção.

6. A indexação de tabelas grandes requer uma abordagem cuidadosa para garantir que os ganhos de desempenho de consultas mais rápidas superem os custos de maior esforço de armazenamento e manutenção.

### **72. Qual é a diferença entre fragmentação e particionamento de banco de dados?**

**1. Fragmentação**

- [A fragmentação](https://www.geeksforgeeks.org/what-is-sharding/) envolve a divisão de um banco de dados em vários **bancos de dados** menores e independentes (fragmentos). Cada fragmento opera em um subconjunto dos dados gerais e pode ser hospedado em servidores separados.
- A fragmentação é uma estratégia de escalabilidade horizontal que distribui dados em vários bancos de dados, normalmente para lidar com grandes volumes de dados e alto tráfego.
- **Finalidade:** dimensionamento horizontal para lidar com grandes volumes de dados e altas cargas de consulta.
- **Exemplo:** um banco de dados de usuários global pode ser dividido em fragmentos por região, como um fragmento para América do Norte, Europa e Ásia.
- **Principal benefício:** cada fragmento pode ser consultado de forma independente, reduzindo a carga em qualquer servidor único.

2. **Particionamento**

- O particionamento divide uma única tabela em partes lógicas menores, geralmente dentro do mesmo banco de dados.
- O particionamento é uma **organização lógica de dados** em um único banco de dados para otimizar o desempenho e a capacidade de gerenciamento.
- **Objetivo:** melhorar o desempenho da consulta reduzindo a quantidade de dados verificados e simplificar as tarefas de manutenção, como arquivamento ou limpeza de dados antigos.
- **Exemplo:** uma tabela de vendas pode ser particionada por ano para que as consultas direcionadas a vendas recentes não precisem verificar dados históricos.

### **73. Quais são as práticas recomendadas para escrever consultas SQL otimizadas?**

**1. Escreva consultas simples e claras:**

- Evite junções e [subconsultas excessivamente complexas](https://www.geeksforgeeks.org/sql-subquery/).
- Use SQL simples, bem estruturado, fácil de ler e manter.

**2. Filtre os dados antecipadamente:**

- Aplique cláusulas WHERE o mais cedo possível para reduzir a quantidade de dados processados.
- Considere o uso de colunas indexadas em cláusulas WHERE para pesquisas mais rápidas.

**3.** ****Evite SELECIONAR** ***:**

- Recupere apenas as colunas necessárias. Isso reduz a E/S e melhora o desempenho.

**4. Use índices com sabedoria:**

- Crie índices em colunas que são frequentemente usadas em cláusulas WHERE, condições JOIN e cláusulas ORDER BY.
- Revise regularmente o uso do índice e remova os índices não utilizados.

**5. Aproveite os planos de execução de consultas:**

- Use planos de execução para identificar gargalos, índices ausentes ou padrões de consulta ineficientes.

**6. Use os tipos de junção apropriados:**

- Escolha INNER JOIN, LEFT JOIN ou OUTER JOIN com base nas relações de dados e nos requisitos de desempenho.

**7. Divida consultas complexas:**

- Em vez de uma única consulta monolítica, use tabelas temporárias ou CTEs para processar dados em estágios.

**8. Otimize as agregações:**

- Use GROUP BY e agregue funções com eficiência.
- Considere a pré-agregação de dados se as consultas exigirem frequentemente os mesmos cálculos.

**9. Monitore o desempenho regularmente:**

- Analise continuamente o desempenho da consulta e ajuste à medida que os volumes de dados aumentam ou os padrões de uso mudam.

### **74. Como você pode monitorar o desempenho da consulta em um banco de dados de produção?**

**1. Use planos de execução:**

Revise o plano de execução de consultas para entender como o banco de dados está recuperando dados, quais índices estão sendo usados e onde existem possíveis gargalos.

**2. Analise as estatísticas de espera:**

Identifique onde as consultas estão esperando, como bloqueios, E/S ou CPU, para identificar a causa da lentidão.

**3. Aproveite as ferramentas de monitoramento integradas:**

- SQL Server: use o Repositório de Consultas, DMVs (Exibições de Gerenciamento Dinâmico) e painéis de desempenho.
- MySQL: use , e o esquema de desempenho.`EXPLAINSHOW PROFILE`
- PostgreSQL: use , e monitoramento baseado em log.`EXPLAIN (ANALYZE)pg_stat_statements`

4. **Configure alertas e linhas de base:**

- Monitore as principais métricas de desempenho (duração da consulta, IOPS, uso da CPU) e defina limites.
- Estabeleça linhas de base para identificar rapidamente quando o desempenho diminui.

5. **Ajuste contínuo de consulta:**

- Revise e ajuste regularmente as consultas à medida que os dados aumentam ou os requisitos do aplicativo mudam.
- Remova índices não utilizados ou ineficientes e reavalie a estratégia de indexação.

### **75. Quais são as compensações de usar indexação versus desnormalização?**

**1. Indexação**

- **Vantagens:**
    - Acelera as operações de leitura e melhora o desempenho da consulta sem alterar a estrutura de dados.
    - Pode ser aplicado de forma incremental e é reversível se não for eficaz.
    - Considere a indexação quando precisar de pesquisas mais rápidas sem alterar o modelo de dados.
- **Desvantagens:**
    - Retarda as operações de gravação, pois os índices precisam ser mantidos.
    - Requer armazenamento adicional.

2. **Desnormalização**

- **Vantagens:**
    - Simplifica a lógica de consulta armazenando dados pré-unidos ou agregados.
    - Pode melhorar o desempenho para cargas de trabalho de leitura pesada em que junções complexas são frequentes.
    - Considere a desnormalização quando junções complexas ou agregações repetidas retardam significativamente as consultas
- **Desvantagens:**
    - Introduz redundância de dados, o que pode levar a inconsistências.
    - Aumenta os requisitos de armazenamento.
    - Torna as atualizações mais complexas, pois os dados redundantes devem ser sincronizados.

### **76. Como o SQL lida com consultas recursivas?**

O SQL lida com **consultas recursivas** usando CTEs (Common **Table Expressions**). Uma CTE recursiva se refere repetidamente para processar dados hierárquicos ou estruturados em árvore.

**Componentes chave:**

- **Membro âncora:** a consulta inicial que inicia a recursão.
- **Membro recursivo:** uma consulta que faz referência à CTE para continuar criando o conjunto de resultados.
- **Condição de terminação:** Garante que a recursão pare depois que uma determinada profundidade ou condição for atendida.

**Exemplo:**

WITH RecursiveCTE (ID, ParentID, Depth) AS (  
    SELECT ID, ParentID, 1 AS Depth  
    FROM Categories  
    WHERE ParentID IS NULL  
    UNION ALL  
    SELECT c.ID, c.ParentID, r.Depth + 1  
    FROM Categories c  
    INNER JOIN RecursiveCTE r  
    ON c.ParentID = r.ID  
)  
SELECT * FROM RecursiveCTE;

### **77. Quais são as diferenças entre consultas transacionais e analíticas?**

**1. Consultas transacionais:**

- Concentre-se em operações individuais e de curto prazo, como inserções, atualizações e exclusões.
- Otimize para alta taxa de transferência e baixa latência.
- Frequentemente usado em sistemas [OLTP](https://www.geeksforgeeks.org/difference-between-olap-and-oltp-in-dbms/) (Online Transaction Processing).

**2. Consultas Analíticas:**

- Envolvem agregações complexas, análises multidimensionais e transformações de dados.
- Normalmente de leitura pesada, processando grandes quantidades de dados históricos ou agregados.
- Frequentemente usado em sistemas OLAP (Online Analytical Processing).

**3. Principais diferenças:**

- **As consultas transacionais** dão suporte às operações diárias e mantêm a integridade dos dados.
- **As consultas analíticas** dão suporte à tomada de decisões, fornecendo insights de grandes conjuntos de dados

### **78. Como você pode garantir a consistência dos dados em bancos de dados distribuídos?**

**1. Use transações distribuídas:** Implemente a confirmação de duas fases (2PC) para garantir que todos os bancos de dados participantes confirmem as alterações simultaneamente ou revertam se alguma parte falhar.

**2. Implemente a consistência eventual:** se uma consistência forte não for necessária, permita que os dados se tornem consistentes ao longo do tempo. Essa abordagem é comum em sistemas distribuídos em que a alta disponibilidade é uma prioridade.

**3. Mecanismos de resolução de conflitos:** use controle de versão, carimbos de data/hora ou regras de detecção de conflitos para resolver inconsistências.

**4. Replicação e sincronização de dados:** Use estratégias de replicação confiáveis para garantir que as alterações feitas em um banco de dados sejam propagadas para outros.

**5. Auditorias e validações regulares:** verifique periodicamente se os dados permanecem consistentes entre os bancos de dados e corrija as discrepâncias conforme necessário.

### **79. Qual é a finalidade do operador SQL PIVOT?**

O [operador PIVOT](https://www.geeksforgeeks.org/pivot-and-unpivot-in-sql/) transforma linhas em colunas, facilitando o resumo ou a reorganização de dados para relatórios.

**Exemplo:**

Converter um conjunto de dados que lista as vendas mensais em um formato que exibe cada mês como uma coluna separada.

SELECT ProductID, [2021], [2022]  
FROM (  
    SELECT ProductID, YEAR(SaleDate) AS SaleYear, Amount  
    FROM Sales  
) AS Source  
PIVOT (  
    SUM(Amount)  
    FOR SaleYear IN ([2021], [2022])  
) AS PivotTable;

### **80. O que é um índice de bitmap e como ele difere de um índice de árvore B?**

**1. Índice de bitmap:**

- Representa dados com bitmaps (matrizes de bits) para indicar a presença ou ausência de um valor em cada linha.
- Eficiente para colunas de baixa cardinalidade, como campos "gênero" ou "sim/não".
- Pode executar operações lógicas rápidas (AND, OR, NOT) em várias colunas simultaneamente.

**2. Índice de árvore B:**

- Usa uma estrutura de árvore balanceada para armazenar dados indexados em uma ordem classificada.
- Adequado para colunas de alta cardinalidade (por exemplo, identificadores exclusivos, grandes intervalos de valores).
- Suporta consultas baseadas em intervalo de forma eficiente.

**3. Diferença chave:**

- Os índices de bitmap se destacam com dados de baixa cardinalidade e condições booleanas complexas.
- Os índices de árvore B são melhores para dados exclusivos ou de alta cardinalidade e consultas de intervalo.

## Perguntas da entrevista SQL baseadas em consulta

Esta seção é dedicada a perguntas que se concentram na **escrita** e **compreensão de consultas SQL**. Ao praticar esses exemplos, aprenderemos **como recuperar**, **manipular** e **analisar dados** de forma eficaz, desenvolvendo as habilidades **de resolução de problemas** necessárias para **cenários do mundo real**.

### 81. Escreva uma consulta para encontrar o segundo maior salário de um funcionário em uma tabela.

SELECT MAX(Salary) AS SecondHighestSalary
FROM Employee
WHERE Salary < (SELECT MAX(Salary) FROM Employee);

**Explicação:**

Essa consulta identifica o segundo salário mais alto selecionando o salário máximo menor que o salário mais alto geral. A subconsulta determina o salário mais alto, enquanto a consulta externa encontra o próximo valor mais alto.

### 82. Escreva uma consulta para recuperar funcionários que ganham mais do que o salário médio.

SELECT * 
FROM Employee 
WHERE Salary > (SELECT AVG(Salary) FROM Employee);

**Explicação:**

Essa consulta busca detalhes de funcionários cujo salário excede o salário médio. A subconsulta calcula o salário médio e a consulta principal filtra as linhas com base nesse resultado.

### 83. **Escreva uma consulta para buscar os valores duplicados de uma coluna em uma tabela.**

SELECT ColumnName, COUNT(*)
FROM TableName
GROUP BY ColumnName
HAVING COUNT(*) > 1;

**Explicação:**

A consulta é usada para agrupar valores idênticos e identificar valores que aparecem mais de uma vez na coluna especificada.`GROUP BYHAVING COUNT(*) > 1`

### 84. Escreva uma consulta para encontrar os funcionários que ingressaram nos últimos 30 dias.

SELECT * 
FROM Employee
WHERE JoiningDate > DATE_SUB(CURDATE(), INTERVAL 30 DAY);

**Explicação:**

Comparando a data atual menos 30 dias, essa consulta recupera todos os funcionários que ingressaram no último mês.`JoiningDate`

### 85. Escreva uma consulta para buscar os 3 funcionários mais bem pagos.

SELECT * 
FROM Employee 
ORDER BY Salary DESC 
LIMIT 3;

**Explicação:**

A consulta classifica os funcionários por salário em ordem decrescente e usa para retornar apenas os três principais ganhadores.`LIMIT 3`

### 86. Escreva uma consulta para excluir linhas duplicadas em uma tabela sem usar a palavra-chave ROWID.

DELETE FROM Employee 
WHERE EmployeeID NOT IN (
   SELECT MIN(EmployeeID)
   FROM Employee
   GROUP BY Column1, Column2
);

**Explicação**:

Essa consulta retém apenas uma linha para cada conjunto de duplicatas, mantendo a linha com o menor . Ele identifica duplicatas usando e remove linhas que não correspondem ao ID mínimo.`EmployeeIDGROUP BY`

### 87. Escreva uma consulta para buscar registros comuns de duas tabelas.

SELECT *
FROM TableA
INNER JOIN TableB ON TableA.ID = TableB.ID;

**Explicação:**

An é usado para localizar linhas presentes em ambas as tabelas, correspondendo a uma coluna comum (neste caso, ).`INNER JOINID`

### 88. Escreva uma consulta para buscar funcionários cujos nomes começam e terminam com 'A'.

SELECT * 
FROM Employee 
WHERE Name LIKE 'A%' AND Name LIKE '%A';

**Explicação:**

A consulta usa caracteres curinga para filtrar linhas em que a coluna começa e termina com a letra 'A'.`LIKEName`

### 89. Escreva uma consulta para exibir todos os departamentos junto com o número de funcionários em cada um.

SELECT DepartmentID, COUNT(*) AS EmployeeCount
FROM Employee
GROUP BY DepartmentID;

**Explicação:**

Ao agrupar os funcionários por suas linhas e contar em cada grupo, a consulta produz uma lista de departamentos junto com a contagem de funcionários.`DepartmentID`

### 90. Escreva uma consulta para encontrar funcionários que não têm gerentes.

SELECT * 
FROM Employee
WHERE ManagerID IS NULL;

**Explicação:**

Essa consulta seleciona funcionários cuja coluna é , indicando que eles não se reportam a um gerente.`ManagerIDNULL`

### **91. Escreva uma consulta para buscar o 3º e o 4º salários mais altos.**

WITH SalaryRank AS (
    SELECT Salary, RANK() OVER (ORDER BY Salary DESC) AS Rank
    FROM Employee
)
SELECT Salary
FROM SalaryRank
WHERE Rank IN (3, 4);

**Explicação:**

Essa consulta usa a função de janela **RANK()** para classificar os salários em ordem decrescente. A consulta externa seleciona o 3º e o 4º salários mais altos, filtrando essas classificações.

### 92. Escreva uma consulta para transpor linhas em colunas.

SELECT 
   MAX(CASE WHEN ColumnName = 'Condition1' THEN Value END) AS Column1,
   MAX(CASE WHEN ColumnName = 'Condition2' THEN Value END) AS Column2
FROM TableName;

**Explicação:**

Essa consulta converte valores de linha específicos em colunas usando agregação condicional com . O valor de cada coluna é determinado com base em uma condição aplicada às linhas.`CASE`

### 93. Escreva uma consulta para buscar registros atualizados na última hora.

SELECT * 
FROM TableName
WHERE UpdatedAt >= NOW() - INTERVAL 1 HOUR;

**Explicação**:

Ao comparar o carimbo de data/hora com a hora atual menos uma hora, a consulta recupera linhas atualizadas nos últimos 60 minutos.`UpdatedAt`

### 94. Escreva uma consulta para listar funcionários em departamentos com menos de 5 funcionários.

SELECT * 
FROM Employee
WHERE DepartmentID IN (
    SELECT DepartmentID 
    FROM Employee 
    GROUP BY DepartmentID 
    HAVING COUNT(*) < 5
);

**Explicação**:

A subconsulta conta os funcionários em cada departamento, e a consulta principal usa esses resultados para encontrar funcionários que trabalham em departamentos com menos de 5 membros.

### 95. Escreva uma consulta para verificar se uma tabela contém algum registro.

SELECT CASE 
       WHEN EXISTS (SELECT * FROM TableName) THEN 'Has Records'
       ELSE 'No Records'
       END AS Status;

**Explicação**:

A consulta é usada para determinar se existem linhas na tabela, retornando um status de 'Tem registros' ou 'Sem registros' com base no resultado.`EXISTS`

### **96. Escreva uma consulta para encontrar funcionários cujos salários sejam mais altos do que seus gerentes.**

SELECT e.EmployeeID, e.Salary
FROM Employee e
JOIN Employee m ON e.ManagerID = m.EmployeeID
WHERE e.Salary > m.Salary;

**Explicação**:

Essa consulta une a tabela a si mesma para comparar os salários dos funcionários com os salários de seus respectivos gerentes, selecionando aqueles que ganham mais.`Employee`

### **97. Escreva uma consulta para buscar linhas alternadas de uma tabela.**

WITH RowNumbered AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS RowNum
    FROM Employee
)
SELECT *
FROM RowNumbered
WHERE RowNum % 2 = 0;

**Explicação**:

Essa consulta atribui um número sequencial a cada linha usando e, em seguida, seleciona as linhas em que o número da linha é par, buscando efetivamente linhas alternadas. O é usado para evitar qualquer ordenação específica e apenas aplicar uma numeração sequencial.`ROW_NUMBER()ORDER BY (SELECT NULL)`

### 98. Escreva uma consulta para encontrar departamentos com o salário médio mais alto.

SELECT DepartmentID
FROM Employee
GROUP BY DepartmentID
ORDER BY AVG(Salary) DESC
LIMIT 1;

**Explicação:**

Agrupando e ordenando pelo salário médio em ordem decrescente, a consulta retorna o departamento com a média mais alta.`DepartmentID`

### 99. Escreva uma consulta para buscar o enésimo registro de uma tabela.

WITH OrderedEmployees AS (
    SELECT *, ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) AS RowNum
    FROM Employee
)
SELECT *
FROM OrderedEmployees
WHERE RowNum = n;

**Explicação**:

Essa consulta usa **ROW_NUMBER()** para gerar um número sequencial para cada linha. A consulta externa recupera a linha em que o número corresponde à posição desejada . A abordagem é portátil na maioria dos bancos de dados.`nth`

### 100. Escreva uma consulta para encontrar funcionários contratados no mesmo mês de qualquer ano.

SELECT * 
FROM Employee
WHERE MONTH(JoiningDate) = MONTH(CURDATE());

**Explicação:**

Ao comparar o mês de com o mês atual, a consulta seleciona todos os funcionários que foram contratados naquele mês, independentemente do ano.`JoiningDate`

### Conclusão

Uma sólida compreensão de SQL é essencial para qualquer pessoa que pretenda trabalhar em **análise de dados**, [administração de banco de dados](https://www.geeksforgeeks.org/dba-full-form/) ou **desenvolvimento de software**. Ao revisar e praticar essas **100 perguntas da entrevista SQL**, ganharemos a **confiança** e o **conhecimento** necessários para responder até mesmo às **perguntas mais difíceis** durante nossa **próxima entrevista**. Lembre-se, a **preparação** é a chave porque cada pergunta que dominamos nos aproxima **de garantir** o **emprego dos sonhos** na indústria de tecnologia.

